<!DOCTYPE html>

<html>

  <head>
    <img src="WebBanner.png" alt="Banner" width="1200" height="300">
      <h1><b>ENG0018 Computer Laboratory 2025/26</b></h1>
      <h2>Student URN: 6935836</h2>
    <hr>
    <h2 style=”font-family:calibri:”><b>Conference paper: How Manufacturing Scale and Moore’s Law Enabled the CPU Bit-Size Revolution</b></h2>
    <hr>

    <!style for tables>
      <style>
        table {
          font-family: arial, sans-serif;
          border-collapse: collapse;
          width: 30%;
        }

        td, th {
          border: 1px solid #dddddd;
          text-align: left;
          padding: 8px;
        }

        tr:nth-child(even) {
          background-color: #dddddd;
        }

        
      </style>

    <style>
      p.ex1 {
        margin-left: 250px;
      }

      p.ex2 {
        margin-right: 100px;
        margin-bottom: 50px;
      }

      p.ref {
        margin-right: 100px;
      }

      p.ref a, p.ex2 a {
        color: #0000EE;
      }

    </style>
  
  </head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">

  <style>
    .mySlides {display:none;}
  </style>

  <!table of contents>
  <table>

    <tr>
      <th><h3>Table of contents</h3></th>
    </tr>
    <tr>
      <td><a href="#Abstract">Abstract</td>
    </tr>
    <tr>
      <td><a href="#Introduction">Introduction</td>
    </tr>
    <tr>
      <td><a href="#The first commercial microprocessor">The first commercial microprocessor</td>
    </tr>
    <tr>
      <td><a href="#Limitations of the 4-bit processor">Limitations of the 4-bit processor</td>
    </tr>
    <tr>
      <td><a href="#Increasing the bit size">Increasing the bit size</td>
    </tr>
    <tr>
      <td><a href="#Transistor production scale">Transistor production scale</td>
    </tr>
    <tr>
      <td><a href="#Moore’s Law">Moore’s Law</td>
    </tr>
    <tr>
      <td><a href="#Conclusion">Conclusion</td>
    </tr>

    <tr>
      <td><a href="#References">References</td>
    </tr>
  </table>

  <body style="background-color:#FFFFFF;margin-left:50px;">
    <hr>
    <h3 id="Abstract">Abstract</h3>
    <p class="ex1">
      <pre>
        This paper presents the historical progression for increasing the bit size of the processor, and the initial challenges faced.
        We examine the transition from 4-bit to modern 64-bit architectures, beginning with the Intel 4004. We then demonstrate how the 2
        obstacles we faced, manufacturing rates and transistor minituarisation, were resolved using Moore's Law and photolithography.
        The article also analyses the impact of increasing the bit size of processors on its performance.
      </pre>
    </p>
    <h3 id="Introduction">Introduction</h3>
    <p class="ex1">
      <pre id="Introduction_InText">
        The CPU (Central Processing Unit) is often regarded as the “brain” of the computer. It performs and executes instructions and carries out
        mathematical and logical operations. It is found inside the billions of technological devices we have today: in smartphones, smartwatches,
        computers, laptops and even washing machines. However, as the demand for processors increased, so does the need for faster, more efficient,
        and more performative processors. In this article, we will analyse how increasing the bit-size directly contributed to the performance of faster
        microprocessors, and how this was achieved.
      </pre>
    </p>
    <h3 id="The first commercial microprocessor">The first commercial microprocessor</h3>
    <p class="ex2" id="Firstprocessor_InText">
      In 1971, Intel created the world's first general purpose microprocessor – <b>the Intel 4004</b>. This processor was made for the Japanese calculator company, Busicom, who had asked Intel to design a chip for their calculating machine <a href="#ref1">(Intel, n.d.)</a>. Intel consequently designed the 4004 microprocessor. It consisted of an Arithmetic Logic Unit (ALU), which performed all the mathematical and logical operations; a set of data registers, which temporarily stored values that the microprocessor needed; and control circuitry, which made use of a data bus to transport the values and information along the different parts of the processor that needed it.
    </p>
    <h3 id="Limitations of the 4-bit processor">Limitations of the 4-bit processor</h3>
    <p class="ex2" id="Limitations_InText">
      The Intel 4004 was a 4-bit microprocessor, which meant it could only carry and process <b>4 binary digits</b> at a time <a href="#ref2">(Faggin, 2018)</a>. A binary digit is 1 or 0, which represents 2 possible states, on or off. As the processor could carry and process 4 binary digits at a time, it meant it could represent a total of 16 possible combinations. This resulted in the Intel 4004 excelling at calculations involving numbers 0-15. However, any calculations resulting or involving numbers above 15 would have to involve programming and hardware workarounds which took a significantly longer amount of time, as the microprocessor was only designed to carry 4 bits <a href="#ref2">(Faggin, 2018)</a>. Thus, this limitation led to the conclusion that <i>increasing the bit size would be necessary to improve the performance of the CPU.</i>
    </p>
    <h3 id="Increasing the bit size">Increasing the bit size</h3>
    <p class="ex2" id="Increasingbitsize_InText">
      In order to increase the bit size, it is essential to understand what transistors are. A transistor functions as a microscopic electronic switch, representing the two binary states, 1 (“on”) and 0 (“off”). They sit on the board of the microprocessor and are necessary for microprocessors to function. The Intel 4004 required approximately 2,300 transistors to function <a href="#ref3">(Faggin, Hoff, Mazor and Smith, 1996)</a>. To increase the bit size from 4 bits to 8 bits, 16 bits or more, Intel would require a substantially larger number of transistors. This would have presented two challenges for Intel. Firstly, scaling up the transistor count directly depended on the manufacturing rates. Manufacturers would have to mass produce thousands, and eventually millions, of microscopic switches that functioned perfectly at faster rates and higher yields. Secondly, Intel would need to be able to achieve a higher transistor density – by packing a significantly greater number of transistors onto the same chip area without increasing the size of the chip. Due to technological constraints at the time, these two problems were a significant barrier to increasing the bit size of processors.
    </p>
    <h3 id="Transistor production scale">Transistor production scale</h3>
    <p class="ex2" id="Transistor_InText">
      The first barrier – yield and production scale - was addressed by rapid advancements in manufacturing taking place at the time. These advances were noted by Faggins, who stated that in 1959 tens of silicon transistors could be fabricated at the same time, but by 1969 it grew to thousands of transistors <a href="#ref2">(Faggin, 2018, para. 1)</a>. An increase in the number of transistors capable of being produced meant that securing a sufficient supply of transistors was no longer a problem for Intel. With more transistors at hand, it directly allowed them to launch the 8008, the first 8-bit processor, in less than 6 months of releasing the 4004. This microprocessor could process 8 binary digits at a time, leading to 256 possible combinations and values that could be represented (letters, numbers, or even symbols) <a href="#ref4">(Morse, Ravenel, Mazor and Pohlman, 1980)</a>. However, while the continual increasing in the production scale of transistors solved Intel’s issue of supply, it did not solve the problem of <i>achieving a higher transistor density.</i>
    </p>
    <h3 id="Moore’s Law">Moore’s Law</h3>
    <figure style="text-align: center; margin: 20px auto;">
      <img src="Picture1.png" alt="Figure 1" style="width:200px; display: block; margin: 0 auto;">
      <figcaption>Figure 1</figcaption>
    </figure>
    <p class="ex2" id="Moore_InText">
      Achieving a higher transistor density was reached through advances in <b>photolithography</b> – the process used to etch microscopic circuits onto silicon. As this technology improved, so did the size of transistors. Transistors could be manufactured at smaller scales and could be miniaturised progressively. This consequently meant more of them could fit onto the surface of the chip, as they were smaller. This progressive advancement led to an industry trend, observed by Gordon Moore, who stated that the number of transistors on an integrated circuit doubled approximately every 2 years <a href="#ref5">(Mack, 2011)</a>. This observation became known as Moore’s Law, and it described the exponential miniaturisation of the transistor that effectively became the breakthrough for Intel’s problem of achieving higher transistor densities <a href="#ref5">(Mack, 2011)</a>. His law became accurate for the next 50 years, as evidenced by <i>Figure 1</i>, and became a guiding principle for the semiconductor industry (Roser, Ritchie and Mathieu, 2023).
    </p>
    <h3 id="Conclusion">Conclusion</h3>
    <p class="ex2" id="Conclusion_InText">
      In this article, we have analysed how increasing the bit-size directly contributed to the performance of microprocessors. We have analysed the two obstacles that had to be overcome to increase the bit size: transistor production and miniaturisation. With the 2 obstacles overcome, the bit size of microprocessors was able to rapidly increase, enabling the progression to 16-bit, 32-bit, and our modern 64-bit processors. The CPU bit-size revolution was consequently achieved by overcoming these 2 challenges - unlocking exponential growth in the performance and processing power of the CPUs that define our digital era.
    </p>
    <h3 id="References">References</h3>
    <p class="ref" id="ref1">Intel (n.d.) <i>Announcing a New Era of Integrated Electronics.</i> Available at: <a href="https://www.intel.com/content/www/us/en/history/virtual-vault/articles/the-intel-4004.html">https://www.intel.com/content/www/us/en/history/virtual-vault/articles/the-intel-4004.html</a> (Accessed: 01 December 2025).</p>
    <p class="ref" id="ref2">Faggin, F. (2018) <i>How we made the microprocessor</i>. Available at: <a href="https://www.nature.com/articles/s41928-017-0014-8">https://www.nature.com/articles/s41928-017-0014-8</a> (Accessed: 01 December 2025).</p>
    <p class="ref" id="ref3">Faggin, F., Hoff, M.E., Mazor, S. and Smith, M. (1996) 'The history of the 4004', <i>IEEE Micro</i>, 16(6), p. 6. Available at: <a href="https://doi.org/10.1109/40.546561">https://doi.org/10.1109/40.546561</a> (Accessed: 01 December 2025).</p>
    <p class="ref" id="ref4">Morse, S.P., Ravenel, B.W., Mazor, S. and Pohlman, W.B. (1980) 'Intel Microprocessors–8008 to 8086', <i>Computer</i>, 13(10), pp. 42-60. Available at: <a href="https://doi.org/10.1109/MC.1980.1653375">https://doi.org/10.1109/MC.1980.1653375</a> (Accessed: 01 December 2025)</p>
    <p class="ref" id="ref5">Mack, C.A. (2011) 'Fifty years of Moore's law', <i>IEEE Transactions on Semiconductor Manufacturing</i>, 24(2), pp. 202-207. Available at: <a href="https://doi.org/10.1109/TSM.2010.2096437">https://doi.org/10.1109/TSM.2010.2096437</a> (Accessed: 01 December 2025).</p>


    <br>
    <video src="video.mp4" width="800" height="450" controls></video>

  <!-- /////////////////////////////////////////// adding last update /////////////////////////////////////////// -->
<!-- /////////////////////////////////////////// -->
<div id="last-updated">Loading last update time...</div>

<!-- Verify Button -->
<button onclick="verifyLastUpdatedTime()" style="display: block; margin: 10px auto; padding: 8px 16px;">  
Verify Last Modified Time  
</button>

<script>
    async function getLastUpdatedTime() {
        const username = 'FEPSFY6935836';
        const repo = 'FY6935836';

        const url = `https://api.github.com/repos/${username}/${repo}/commits`;

        try {
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Accept': 'application/vnd.github.v3+json',
                }
            });
            if (!response.ok) {
                throw new Error(`Error fetching data: ${response.status} - ${response.statusText}`);
            }

            const commits = await response.json();
            if (commits && commits.length > 0) {
                const lastCommitDate = new Date(commits[0].commit.committer.date);

                // Displaying the time on load
                document.getElementById('last-updated').innerText = `Last Modified Time: ${lastCommitDate.toLocaleString()}`;
            } else {
                document.getElementById('last-updated').innerText = `No commits found in the repository.`;
            }
        } catch (error) {
            console.error('Error fetching the last updated time:', error);
            document.getElementById('last-updated').innerText = `Error fetching update time. Please check the repository details.`;
        }
    }

    // Function to verify the last update time by re-fetching it from the API  
    async function verifyLastUpdatedTime() {
        document.getElementById('last-updated').innerText = `Verifying...`;
        await getLastUpdatedTime();
        alert('Last modified time has been successfully verified from Github API.');
    }

    // Initial load to display the time on page load  
    window.onload = getLastUpdatedTime;  
</script>

<!-- //////////////////////////////////////////////////////////////
<!-- ////////////////////////////////////////////////////////////// Word count function //////////////////////////////////////////////////////////////
<!-- //////////////////////////////////////////////////////////////

<!-- Placeholder for total word count -->
<p id="totalWordCount"></p>

<hr>

<script>
    // Function to calculate and display word count for a specified section
    function displayWordCount(sectionId, outputId) {
        // Get the text content from the specified section
        const text = document.getElementById(sectionId).textContent;

        // Split text into words based on spaces and filter out any empty strings
        const wordArray = text.trim().split(/\s+/);

        // Count the words
        const wordCount = wordArray.length;

        // Return the word count for summing purposes
        return wordCount;
    }

    // Function to calculate and display total word count from selected sections
    function displayTotalWordCount() {
        // Calculate word count for each section and accumulate the total
        const IntroductionCount = displayWordCount("Introduction_InText");
        const FirstprocessorCount = displayWordCount("Firstprocessor_InText");
        const LimitationsCount = displayWordCount("Limitations_InText");
        const IncreasingbitsizeCount = displayWordCount("Increasingbitsize_InText");
        const TransistorCount = displayWordCount("Transistor_InText");
        const MooreCount = displayWordCount("Moore_InText");
        const ConclusionCount = displayWordCount("Conclusion_InText");

        // Calculate the sum of all selected sections
        const totalWordCount = IntroductionCount + FirstprocessorCount + LimitationsCount + IncreasingbitsizeCount + TransistorCount + MooreCount + ConclusionCount;

        // Display the total word count
        document.getElementById("totalWordCount").innerText = `Total word count: ${totalWordCount}`;
    }

    // Run the function for specific sections and display total count when the page loads
    window.onload = displayTotalWordCount;
</script>
  
  </body>  
</html>
